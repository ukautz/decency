package Mail::Decency::Core::Locker;

use Mouse::Role;
use version 0.74; our $VERSION = qv( "v0.2.0" );

use Data::Dumper;
use Data::Pager;

use Time::HiRes qw/ usleep ualarm /;
use Carp qw/ confess /;

our $DEFAULT_DEADLOCK_TIMEOUT = 2_000_000;

=head1 NAME

Mail::Decency::Core::Locker

=head1 DESCRIPTION

Adds locker methods to servers which can be used from databases and so on.

=head1 SYNPOSIS

Create a new datbaase like this:

    Mail::Decency::Helper::Database->create( MongoDB => $config_ref );


=head1 CLASS ATTRIBUTES

=head2 lockers : HashRef[IPC::Semaphore]

=cut

has lockers => ( is => "rw", isa => 'HashRef[IPC::Semaphore]', default => sub { {} } );

=head2 locker_pids : HashRef[Int]

PID of process creating the semaphore

=cut

has locker_pids => ( is => "rw", isa => 'HashRef[Int]', default => sub { {} } );

=head2 locker_pids : HashRef[Int]

PID of process creating the semaphore

=cut

has locker_timeouts => ( is => "rw", isa => 'HashRef[Int]', default => sub { {} } );


=head1 METHODS

=cut

before BUILD => sub {
    my ( $self ) = @_;
};

after DEMOLISH => sub {
    my ( $self ) = @_;
    print "** DEMOLISH LOCKER **\n";
    foreach my $name( keys %{ $self->lockers } ) {
        delete $self->lockers->{ $name };
    }
};


=head2 set_locker

=cut

sub set_locker {
    my ( $self, $name, %args ) = @_;
    $name ||= 'default';
    my $locker;
    if ( ref( $name ) ) {
        $locker = $name;
        $name = 'default';
    }
    
    # alreadythere ?
    if ( defined $self->lockers->{ $name }
        && ref( $self->lockers->{ $name } ) =~ /^_IPC_Semaphore/
    ) {
        return $self->lockers->{ $name };
    }
    
    
    # timeout
    my $timeout = $args{ timeout } || $DEFAULT_DEADLOCK_TIMEOUT;
    $timeout *= 1_000_000 if $timeout < 100_000;
    
    # create locker only for master process. others use the provided locker
    unless ( $locker ) {
        $locker = _IPC_Semaphore->new( $name, undef )
            or die "Cannot create IPC Semaphore for locking: $!\n";
        $locker->setall( (1) x 3 )
            or die "Cannot initial unlock semaphores: $!\n";
    }
    else {
        $locker = _IPC_Semaphore->new( $name, $locker )
    }
    
    $self->locker_timeouts->{ $name } = $timeout;
    return $self->lockers->{ $name } = $locker;
}

*locker = *set_locker;

=head2 do_lock

Locks via flock file

=cut

sub do_lock {
    my ( $self, $name, $num ) = @_;
    $num ||= 0;
    
    my $locker = $self->locker( $name )
        or die "No locker for '$name' found";
    
    # !! ATTENTION !!
    #   the purpose of this locking is to ensure increments in multi-forking
    #   environment work. The purpose is NOT to assure absolute mutual
    #   exclusion. 
    #   worst case for data: some counter are not incremented
    #   worst case for process: slow response (not to speak of deadlock)
    #   the process needs overrule the (statistic) data needs.
    # !! ATTENTION !!
    my $timeout = $self->locker_timeouts->{ $name } || $DEFAULT_DEADLOCK_TIMEOUT;
    my $deadlock = $timeout;
    eval {
        $SIG{ ALRM } = sub {
            die "Deadlock timeout in $name after $timeout\n";
        };
        ualarm( $deadlock );
        $locker->op( $num, -1, 0 );
    };
    ualarm( 0 );
    if ( $@ ) {
        $locker->setval( $num, 0 );
    }
}


=head2 do_unlock

Unlocks the flock

=cut

sub do_unlock {
    my ( $self, $name, $num ) = @_;
    $num ||= 0;
    my $locker = $self->locker( $name )
        or die "No locker for '$name' found";
    $locker->op( $num, 1, 0 );
}

=head2 read_lock

Do read lock

=cut

sub read_lock {
    my ( $self, $name ) = @_;
    return $self->do_lock( $name, 1 );
}

=head2 read_unlock

Do unlock read

=cut

sub read_unlock {
    my ( $self, $name ) = @_;
    return $self->do_unlock( $name, 1 );
}



=head2 write_lock

Do read lock

=cut

sub write_lock {
    my ( $self, $name ) = @_;
    $self->read_lock( $name );
    $self->do_lock( $name, 2 );
    return ;
}

=head2 write_unlock

Do unlock read

=cut

sub write_unlock {
    my ( $self, $name ) = @_;
    $self->do_unlock( $name, 2 );
    $self->read_unlock( $name );
}

=head2 usr_lock

Custom locker

=cut

sub usr_lock {
    my ( $self, $name ) = @_;
    return $self->do_lock( $name, 0 );
}

=head2 usr_lock

Custom locker

=cut

sub usr_unlock {
    my ( $self, $name ) = @_;
    return $self->do_unlock( $name, 0 );
}


=head1 AUTHOR

Ulrich Kautz <uk@fortrabbit.de>

=head1 COPYRIGHT

Copyright (c) 2011 the L</AUTHOR> as listed above

=head1 LICENCSE

This library is free software and may be distributed under the same terms as perl itself.

=cut

package _IPC_Semaphore;

use IPC::Semaphore;
use IPC::SysV qw/ IPC_PRIVATE IPC_CREAT IPC_EXCL S_IRWXU /;
use Scalar::Util qw/ refaddr /;

our %COUNT_SEM = ();

sub new {
    my ( $class, $name, $semaphore, @args ) = @_;
    
    $COUNT_SEM{ $name } ||= {};
    
    if ( ! $semaphore && ( my $meth = IPC::Semaphore->can( 'SEMAPHORE_'. $name ) ) ) {
        my $semaphore_id = IPC::Semaphore->$meth();
        $semaphore = IPC::Semaphore->new( $semaphore_id, 3, S_IRWXU | IPC_CREAT );
        print "#### REUSE SEMAPHORE IN $name: $semaphore_id (". $semaphore->id .")\n";
    }
    elsif ( !$semaphore ) {
        $semaphore = IPC::Semaphore->new( IPC_PRIVATE, 3, S_IRWXU | IPC_CREAT );
        print "#### CREATE SEMAPHORE IN $name: (". $semaphore->id .")\n";
    }
    
    die "Could not create another semaphore!\n"
        unless $semaphore;
    
    print "#### USE SEM ". $semaphore->id. " IN $name FOR ". refaddr( $semaphore ). "\n";
    
    unless ( $semaphore->can( 'SEMAPHORE_'. $name ) ) {
        my $semaphore_id = $semaphore->id;
        {
            no strict 'refs';
            *{ 'IPC::Semaphore::SEMAPHORE_IDS_'. $name } = {};
            *{ 'IPC::Semaphore::SEMAPHORE_'. $name } = sub {
                return $semaphore_id;
            };
            *{ 'IPC::Semaphore::SEMAPHORE_ADD_'. $name } = sub {
                my ( $add_addr ) = @_;
                print "++++ ADD ADDR TO $name: $add_addr\n";
                my $count_ref = *{ 'IPC::Semaphore::SEMAPHORE_IDS_'. $name };
                if ( $add_addr ) {
                    $count_ref->{ $add_addr } ++;
                }
                return scalar( keys %$count_ref );
            };
            *{ 'IPC::Semaphore::SEMAPHORE_REMOVE_'. $name } = sub {
                my ( $remove_addr ) = @_;
                print "++++ REMOVE ADDR FROM $name: $remove_addr\n";
                my $count_ref = *{ 'IPC::Semaphore::SEMAPHORE_IDS_'. $name };
                delete $count_ref->{ $remove_addr };
                return scalar( keys %$count_ref );
            };
        }
    }
    
    my $self = bless {
        name       => $name,
        semaphore  => $semaphore
    }, $class;
    
    {
        no strict 'refs';
        *{ 'IPC::Semaphore::SEMAPHORE_ADD_'. $name }->( refaddr( $self ) );
    }
    
    return $self;
}

sub op { shift->{ semaphore }->op( @_ ) }
sub setval { shift->{ semaphore }->setval( @_ ) }
sub setall { shift->{ semaphore }->setall( @_ ) }

sub DESTROY {
    my ( $self ) = @_;
    
    
    my $count = 0;
    {
        no strict 'refs';
        $count = *{ 'IPC::Semaphore::SEMAPHORE_REMOVE_'. $self->{ name } }->( refaddr( $self ) );
    }
    
    if ( $count == 0 ) {
        print ">> FOUND AND DO REMOVE $self->{ semaphore } ($self)\n";
        $self->{ semaphore }->remove;
    }
}


1;

